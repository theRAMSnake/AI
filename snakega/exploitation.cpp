#include "exploitation.hpp"
#include "decoder.hpp"
#include "neuroevolution/rng.hpp"
#include "logger/Logger.hpp"
#include "cmaes.h"
#include <algorithm>
#include "fitness_weighted_pool.hpp"

namespace snakega
{

Exploitation::Exploitation(const Pop& src, const std::size_t size)
: mSrc(src)
{
    
}

double evaluate(const double* x, const int N, neuroevolution::IFitnessEvaluator* eval, const neuroevolution::DomainGeometry* geometry, Genom* genom)
{
    auto iter = genom->mConnections.begin();

    for (int i = 0; i < N; ++i)
    {
        iter->weight = x[i];
        iter++;
    }

    auto nn = GenomDecoder::decode(*geometry, *genom);
    return eval->evaluate(*nn);
}

Pop Exploitation::run(
   const std::size_t depth, 
   const MutationConfig& cfg, 
   const neuroevolution::DomainGeometry& geometry, 
   neuroevolution::IFitnessEvaluator& eval
   )
{
    int dim = mSrc.mGenom.getComplexity();

    if (dim == 0)
    {
        return mSrc;
    }

    std::vector<double> x0(dim);
    std::transform(mSrc.mGenom.mConnections.begin(), mSrc.mGenom.mConnections.end(), x0.begin(), [](auto x) {return x.weight; });
    
    double sigma = 1.0;

    libcmaes::CMAParameters<> cmaparams(x0, sigma);
    cmaparams.set_algo(aCMAES);
    cmaparams.set_max_iter(depth);
    libcmaes::FitFunc f = std::bind(evaluate, std::placeholders::_1, std::placeholders::_2, &eval, &geometry, &mSrc.mGenom);
    libcmaes::CMASolutions sols = libcmaes::cmaes<>(f, cmaparams);

    mSrc.mFitness = std::round(sols.get_best_seen_candidate().get_fvalue());
    auto result = sols.get_best_seen_candidate().get_x();

    auto iter = mSrc.mGenom.mConnections.begin();
    for (auto w : result)
    {
        iter->weight = w;
        iter++;
    }

    return mSrc;
}

}