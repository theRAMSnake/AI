#include "exploitation.hpp"
#include "decoder.hpp"
#include "neuroevolution/rng.hpp"

namespace snakega
{

Exploitation::Exploitation(const Pop& src, const std::size_t size)
: mSrc(src)
, mSize(size)
{
   
}

Pop Exploitation::run(
   const std::size_t depth, 
   const MutationConfig& cfg, 
   const neuroevolution::DomainGeometry& geometry, 
   neuroevolution::IFitnessEvaluator& eval
   )
{
   std::size_t numStagnant = 0;
   neuroevolution::Fitness maxFitness = 0;
   while(true)
   {
      select(cfg);
      reproduce(cfg);
      evaluate(geometry, eval); 

      if(mLocalPops[0].mFitness > maxFitness)
      {
         maxFitness = mLocalPops[0].mFitness;
         numStagnant = 0;
      }
      else
      {
         numStagnant++;
      }

      if(numStagnant == depth)
      {
         break;
      }
   }

   return mLocalPops[0];
}

void Exploitation::select(const MutationConfig& cfg)
{
   if(mLocalPops.empty())
   {
      mLocalPops.reserve(mSize);
      mLocalPops.push_back(mSrc);

      while(mLocalPops.size() < mSize)
      {
         auto curPop = mSrc;
         curPop.mutateParameters(cfg);
         mLocalPops.push_back(curPop);
      };
   }
   else
   {
      //Just pick top 25%
      mLocalPops.resize(mLocalPops.size() / 4);
   }
}

void Exploitation::reproduce(const MutationConfig& cfg)
{
   //Use selected genes of previous generation and mutate them to get new generation
   auto lastGen = mLocalPops;

   while(mLocalPops.size() < mSize)
   {
      auto pop = lastGen[Rng::genChoise(lastGen.size())];

      pop.mutateParameters(cfg);

      mLocalPops.push_back(pop);
   }
}

static bool comparePopsByFitness(const Pop& a, const Pop& b)
{
   return a.mFitness > b.mFitness;
}

void Exploitation::evaluate(const neuroevolution::DomainGeometry& geometry, neuroevolution::IFitnessEvaluator& eval)
{
   for(auto& pop : mLocalPops)
   {
      pop.mFitness = eval.evaluate(*GenomDecoder::decode(geometry, pop.mGenom));
   }

   std::sort(mLocalPops.begin(), mLocalPops.end(), comparePopsByFitness);
}

}