#include "exploitation.hpp"
#include "decoder.hpp"
#include "neuroevolution/rng.hpp"
#include "logger/Logger.hpp"
#include <algorithm>

namespace snakega
{

Exploitation::Exploitation(const Pop& src, const std::size_t size, const std::size_t depth)
: mSrc(src)
, mSize(size)
, mDepth(depth)
{
    
}

Pop Exploitation::run(
   neuroevolution::IFitnessEvaluator& eval
   )
{
    neuroevolution::Fitness maxFitness = 0;
    for (int i = 0; i < mDepth; ++i)
    {
        select();
        reproduce();
        evaluate(eval);
    }

    return mLocalPops[0];
}

void Exploitation::select()
{
    if (mLocalPops.empty())
    {
        mLocalPops.reserve(mSize);
        mLocalPops.push_back(mSrc);

        while (mLocalPops.size() < mSize)
        {
            auto curPop = mSrc;
            curPop.mutateParameters();
            mLocalPops.push_back(curPop);
        };
    }
    else
    {
        //Just pick top 25%
        mLocalPops.resize(mLocalPops.size() / 4);
    }
}

void Exploitation::reproduce()
{
    //Use selected genes of previous generation and mutate them to get new generation
    auto lastGen = mLocalPops;

    while (mLocalPops.size() < mSize)
    {
        auto pop = lastGen[Rng::genChoise(lastGen.size())];

        pop.mutateParameters();

        mLocalPops.push_back(pop);
    }
}

static bool comparePopsByFitness(const Pop & a, const Pop & b)
{
    return a.fitness > b.fitness;
}

void Exploitation::evaluate(neuroevolution::IFitnessEvaluator& eval)
{
    for (auto& pop : mLocalPops)
    {
        auto agent = neuroevolution::NNAgent(pop.mGenom.getNumInputs(), pop.mGenom.getNumOutputs(), GenomDecoder::decode(pop.mGenom));
        pop.fitness = eval.evaluate(agent);
    }

    std::sort(mLocalPops.begin(), mLocalPops.end(), comparePopsByFitness);
}

}