#include "exploitation.hpp"
#include "decoder.hpp"
#include "neuroevolution/rng.hpp"

namespace snakega
{

Exploitation::Exploitation(const Pop& src, const std::size_t size)
: mSrc(src)
, mSize(size)
{
   
}

Pop Exploitation::run(const std::size_t depth, const MutationConfig& cfg, neuroevolution::IFitnessEvaluator& eval)
{
   for(std::size_t i = 0; i < depth; ++i)
   {
      select(cfg);
      reproduce(cfg);
      evaluate(eval); 
   }

   return mLocalPops[0];
}

void Exploitation::select(const MutationConfig& cfg)
{
   if(mLocalPops.empty())
   {
      mLocalPops.reserve(mSize);
      mLocalPops.push_back(mSrc);

      while(mLocalPops.size() < mSize)
      {
         auto curPop = mSrc;
         curPop.mutateParameters(cfg);
         mLocalPops.push_back(curPop);
      };
   }
   else
   {
      //Just pick top 25%
      mLocalPops.resize(mLocalPops.size() / 4);
   }
}

void Exploitation::reproduce(const MutationConfig& cfg)
{
   //Use selected genes of previous generation and mutate them to get new generation
   auto lastGen = mLocalPops;

   while(mLocalPops.size() < mSize)
   {
      auto pop = lastGen[Rng::genChoise(lastGen.size())];

      pop.mutateParameters(cfg);

      mLocalPops.push_back(pop);
   }
}

static bool comparePopsByFitness(const Pop& a, const Pop& b)
{
   return a.mFitness > b.mFitness;
}

void Exploitation::evaluate(neuroevolution::IFitnessEvaluator& eval)
{
   for(auto& pop : mLocalPops)
   {
      pop.mFitness = eval.evaluate(*GenomDecoder::decode(pop.mGenom));
   }

   std::sort(mLocalPops.begin(), mLocalPops.end(), comparePopsByFitness);
}

}